# 从输入URL到页面加载过程

### 大致流程

1. 强缓存（不发请求）
2. 域名解析（DNS查询）
3. (SSL/TLS)握手
4. TCP三次握手
5. 发送请求（应用层）
6. 服务器收到请求
7. 协商缓存（服务器告诉浏览器使用本地缓存）
8. 微服务架构 -> 负载均衡
9. 服务器处理请求 并返回响应
10. TCP四次挥手（关闭连接）
11. DOM树 + CSS树 -> 渲染树 (边加载边解析)
12. JS资源要等脚本下载完成并执行后才会继续解析HTML（此时可以使用defer和async）
    * defer是延迟执行。类似放在body后面
    * async是异步执行。下载完毕执行

### 网络传输过程

![因特网](/md/img/interweb.png)


### 域名解析

IP 查找顺序（查询到就返回）
1. 首先从`浏览器缓存`中查找 IP
2. 从`Host文件`中查找 IP
3. 从`路由器`缓存中查找 IP
4. 发送`DNS请求`到 本地DNS服务器（运营商）
5. 从`本地DNS服务器`缓存中查找 IP
6. 以`递归`的方式往`根DNS服务器`发起请求
7. 以`迭代`的方式获取能查询的`顶级域名服务器`位置
8. 顶级服务器告诉本地DNS到`权限服务器`上查询
9. 权限服务器将IP返回给本地DNS
10. 本地DNS将IP保存到自己的缓存中

概念：
* DNS 即 (domain name system，域名系统)，一个域名和IP地址相互映射的分布式数据库。
* 根域名：全球共13个根服务器 (包含所有顶级域名服务器的域名和IP地址)
* 顶级域名：域名的最后一部分（如：.com、.cn、.net 等）
* 二级域名：域名的倒数第二个部分，如：example.baidu.com中，二级域名是Baidu



### HTTPS

> HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 超文本传输**安全**协议）


HTTPS在传统的HTTP和TCP之间加了一层用于`加密解密的SSL/TLS层`（安全套接层Secure Sockets Layer/安全传输层Transport Layer Security）层。使用HTTPS必须要有一套自己的数字证书（**包含公钥和私钥**）。

HTTPS解决的问题
* 信息加密传输：第三方无法窃听；
* 校验机制：一旦被篡改，通信双方会立刻发现；
* 身份证书：防止身份被冒充。


HTTPS加密过程：
1. 客户端请求服务器获取`证书公钥`
2. 客户端(SSL/TLS)解析证书（无效会弹出警告）
3. 生成随机值
4. 用`公钥加密`随机值生成**密钥**
5. 客户端将`秘钥`发送给服务器
6. 服务端用`私钥`解密`秘钥`得到随机值
7. `将信息和随机值混合在一起`进行对称加密
8. 将加密的内容发送给客户端
9. 客户端用`秘钥`解密信息

![HTTPS](/md/img/https.png)

加密过程使用了对称加密和非对称加密。
* 对称加密: **客户端和服务端采用相同的密钥经行加密**
    ```
        encrypt(明文，秘钥) = 密文

        decrypt(密文，秘钥) = 明文
    ```
* 非对称加密：**客户端通过公钥加密。服务端通过私钥解密**
    ```
        encrypt(明文，公钥) = 密文

        decrypt(密文，私钥) = 明文
    ```


因为TLS握手的过程中采用了非对称加密，客户端本身不知道服务器的秘钥，这样通信就不会被中间人劫持。此外这一步服务端还提供了证书，并且可能要求客户端提供证书。关于证书下文会提到，只要有了证书，就能保证和你通信的对方是真实的，而不是别人伪造的。


那然后验证证书呢？
1. 客户端获取到了站点证书，拿到了站点的公钥
2. 客户端找到其站点证书颁发者的信息
4. `站点证书的颁发者`验证`服务端站点`是否可信
5. 往上回溯，找到`根证书颁发者`
6. 通过`根证书颁发者`一步步验证`站点证书颁布者`是否可信


附：
* HTTPS默认使用443端口，而HTTP默认使用80端口。
* TLS就是从SSL发展而来的，只是SSL发展到3.0版本后改成了TLS
* 第一次请求中TLS握手的代价很大
* 后续的请求会共用第一次请求的协商结果

参考：
* [刘某某_adf3](https://www.jianshu.com/p/954961bac588)
* [jimsshom](https://www.jianshu.com/p/24af67c40e8d)



### TCP三次握手

1. 客户端请求建立连接
2. 服务端确认应答
3. 客户端确认应答

    → ← →

三次握手期间，任何1次未收到对面的回复，则都会重发

> 目的：应对网络延迟问题，防止网络资源浪费，甚至死锁


### TCP四次挥手

1. 客户端请求断开连接
2. 服务端应答
3. 服务端请求断开连接
4. 客户端应答

    → ← ← →

> 目的：保证双方都断开连接


### 浏览器缓存

浏览器缓存策略相关：比如Cache-Control、~~Pragma~~、ETag、Expires、Last-Modified

**强缓存**是利用`Expires`或者`Cache-Control`这两个http header实现的，命中缓存会返回`200`（不请求服务器）
* expires有服务器时间和客户端时间不一致导致失效的问题
* Cache-Control在`HTTP 1.1`中为了解决expires的问题而诞生
  * 单位为秒，不依赖客户端时间
  * （优先级高于Expires）

**协商缓存**利用`Last-Modified`或者`Etag`这两个http header实现，命中缓存会返回`304`（请求服务器）
* Last-Modified比较前一个响应头的`Last-Modified`和新请求头的`if-modified-since`（单位秒）
  * 根据时间来缓存
  * 最后修改只能精确到秒级
  * 定期生成文件内容没变化时Last-Modified改变
* Etag在`HTTP 1.1`中出现：比较前一个响应头的`Etag`和新请求头的`If-None-Match`，
  * 优先级高于Last-Modified
  * 基于资源的内容编码生成一串唯一的标识`字符串`来缓存


在文件变动的时候需要清除缓存。比如：在webpack打包的时候一般会给JS、CSS、图片的文件名添加`chunkhash`。


[参考](https://www.jianshu.com/p/65605622234b)
