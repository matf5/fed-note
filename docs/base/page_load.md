# 从输入URL到页面加载过程

### 大致流程

1. 强缓存（不发请求）
2. 域名解析（DNS查询）
3. [(SSL/TLS)握手](/base/https.md)
4. TCP三次握手
5. 发送请求（应用层）
6. 服务器收到请求
7. 协商缓存（服务器告诉浏览器使用本地缓存）
8. 微服务架构 -> 负载均衡
9. 服务器处理请求 并返回响应
10. TCP四次挥手（关闭连接）
11. DOM树 + CSS树 -> 渲染树 (边加载边解析)
12. JS资源要等脚本下载完成并执行后才会继续解析HTML（此时可以使用defer和async）
    * defer是延迟执行。类似放在body后面
    * async是异步执行。下载完毕执行

### 网络传输过程

![因特网](/md/img/interweb.png)

### 域名解析

IP 查找顺序（查询到就返回）
1. 首先从`浏览器缓存`中查找 IP
2. 从`Host文件`中查找 IP
3. 从`路由器`缓存中查找 IP
4. 发送`DNS请求`到 本地DNS服务器（运营商）
5. 从`本地DNS服务器`缓存中查找 IP
6. 以`递归`的方式往`根DNS服务器`发起请求
7. 以`迭代`的方式获取能查询的`顶级域名服务器`位置
8. 顶级服务器告诉本地DNS到`权限服务器`上查询
9. 权限服务器将IP返回给本地DNS
10. 本地DNS将IP保存到自己的缓存中

概念：
* DNS 即 (domain name system，域名系统)，一个域名和IP地址相互映射的分布式数据库。
* 根域名：全球共13个根服务器 (包含所有顶级域名服务器的域名和IP地址)
* 顶级域名：域名的最后一部分（如：.com、.cn、.net 等）
* 二级域名：域名的倒数第二个部分，如：example.baidu.com中，二级域名是Baidu

### TCP三次握手

1. 客户端请求建立连接
2. 服务端确认应答
3. 客户端确认应答

    → ← →

三次握手期间，任何1次未收到对面的回复，则都会重发

> 目的：应对网络延迟问题，防止网络资源浪费，甚至死锁


### TCP四次挥手

1. 客户端请求断开连接
2. 服务端应答
3. 服务端请求断开连接
4. 客户端应答

    → ← ← →

> 目的：保证双方都断开连接

### 浏览器缓存

浏览器缓存策略相关：比如Cache-Control、~~Pragma~~、ETag、Expires、Last-Modified

**强缓存**是利用`Expires`或者`Cache-Control`这两个http header实现的，命中缓存会返回`200`（不请求服务器）
* expires有服务器时间和客户端时间不一致导致失效的问题
* Cache-Control在`HTTP 1.1`中为了解决expires的问题而诞生
  * 单位为秒，不依赖客户端时间
  * （优先级高于Expires）

**协商缓存**利用`Last-Modified`或者`Etag`这两个http header实现，命中缓存会返回`304`（请求服务器）
* Last-Modified比较前一个响应头的`Last-Modified`和新请求头的`if-modified-since`（单位秒）
  * 根据时间来缓存
  * 最后修改只能精确到秒级
  * 定期生成文件内容没变化时Last-Modified改变
* Etag在`HTTP 1.1`中出现：比较前一个响应头的`Etag`和新请求头的`If-None-Match`，
  * 优先级高于Last-Modified
  * 基于资源的内容编码生成一串唯一的标识`字符串`来缓存



在文件变动的时候需要清除缓存。比如：在webpack打包的时候一般会给JS、CSS、图片的文件名添加`chunkhash`。



[参考](https://www.jianshu.com/p/65605622234b)