(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{375:function(t,s,a){"use strict";a.r(s);var e=a(42),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"算法基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法基础"}},[t._v("#")]),t._v(" 算法基础")]),t._v(" "),a("h2",{attrs:{id:"五大算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五大算法"}},[t._v("#")]),t._v(" 五大算法")]),t._v(" "),a("h3",{attrs:{id:"一、分治算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、分治算法"}},[t._v("#")]),t._v(" 一、分治算法")]),t._v(" "),a("blockquote",[a("p",[t._v("将规模为 N 的问题分解为 K 个规模较小的子问题，这些"),a("strong",[t._v("子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解")])])]),t._v(" "),a("p",[t._v("举例：")]),t._v(" "),a("h3",{attrs:{id:"二、动态规划算法（dynamic-programming，简称：dp）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、动态规划算法（dynamic-programming，简称：dp）"}},[t._v("#")]),t._v(" 二、动态规划算法（Dynamic Programming，简称：DP）")]),t._v(" "),a("blockquote",[a("p",[t._v("类似于分治算法，将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，"),a("strong",[t._v("经分解得到子问题往往不是互相独立的")])])]),t._v(" "),a("p",[t._v("举例：斐波那契数列 0,1,1,2,3,5,8,13,…")]),t._v(" "),a("p",[t._v("它的每个数字都与前两个紧邻的数字相关。如果 F(n) 是第 n 个数字，那么我们会有 "),a("code",[t._v("F(n) = F(n-1) + F(n-2)")]),t._v("。这个在数学上称作"),a("em",[t._v("递归方程")]),t._v("或者"),a("em",[t._v("递推关系")]),t._v("。为了计算后面的项，它需要前面项的计算结果作为输入")]),t._v(" "),a("h3",{attrs:{id:"三、贪心算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、贪心算法"}},[t._v("#")]),t._v(" 三、贪心算法")]),t._v(" "),a("blockquote",[a("p",[t._v("在对问题求解时，"),a("strong",[t._v("总是做出在当前看来是最好的选择")]),t._v("。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解")])]),t._v(" "),a("p",[t._v("案例："),a("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/",target:"_blank",rel:"noopener noreferrer"}},[t._v("买卖股票的最佳时机 II"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。")]),t._v(" "),a("p",[t._v("设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。")]),t._v(" "),a("p",[t._v("注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。")]),t._v(" "),a("p",[t._v("示例 1:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("输入: [7,1,5,3,6,4]\n\n输出: 7\n\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n")])])]),a("p",[t._v("解题思路："),a("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("从第 i 天（这里 i >= 1）开始，与第 i - 1 的股价进行比较，如果股价有上升（严格上升），就将升高的股价（ prices[i] - prices[i- 1] ）记入总利润，按照这种算法，得到的结果就是符合题意的最大利润。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 也就是说只要能赚钱就进行一次买卖。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" res "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" prices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" prices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" prices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等价于")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" res "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  prices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" prices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),a("h3",{attrs:{id:"四、回溯算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、回溯算法"}},[t._v("#")]),t._v(" 四、回溯算法")]),t._v(" "),a("blockquote",[a("p",[t._v("回溯法是一种搜索算法，类似枚举的搜索尝试过程。复杂的，规模较大的问题都可以使用回溯法")])]),t._v(" "),a("p",[t._v("案例：八皇后问题")]),t._v(" "),a("h3",{attrs:{id:"五、分支限界法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、分支限界法"}},[t._v("#")]),t._v(" 五、分支限界法")]),t._v(" "),a("blockquote",[a("p",[t._v("回溯算法是深度优先，那么分支限界法就是广度优先的一个经典的例子。回溯法一般来说是遍历整个解空间，获取问题的所有解，而分支限界法则是获取一个解")])]),t._v(" "),a("h2",{attrs:{id:"算法技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法技巧"}},[t._v("#")]),t._v(" 算法技巧")]),t._v(" "),a("h3",{attrs:{id:"双指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双指针"}},[t._v("#")]),t._v(" 双指针")]),t._v(" "),a("blockquote",[a("p",[t._v("双指针在处理链表的时候特别有用")])]),t._v(" "),a("p",[t._v("案例1：判断单链表是否成环（快慢指针）")]),t._v(" "),a("p",[t._v("如果单链表成环，那么必定出现慢指针和快指针重合的情况")]),t._v(" "),a("p",[t._v("案例2: "),a("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/",target:"_blank",rel:"noopener noreferrer"}},[t._v("删除排序数组中的重复项"),a("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=r.exports}}]);