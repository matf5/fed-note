<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>算法基础 | Mokou的小书房</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Mokou,源码解析,前端,Vue,Vue3,Es6,Javascript">
    <link rel="preload" href="/fed-note/assets/css/0.styles.35bbaf6d.css" as="style"><link rel="preload" href="/fed-note/assets/js/app.15a9732a.js" as="script"><link rel="preload" href="/fed-note/assets/js/2.6fa16ecd.js" as="script"><link rel="preload" href="/fed-note/assets/js/6.13ba1568.js" as="script"><link rel="prefetch" href="/fed-note/assets/js/10.1c5ba5b8.js"><link rel="prefetch" href="/fed-note/assets/js/11.e99e6c41.js"><link rel="prefetch" href="/fed-note/assets/js/12.ec71da84.js"><link rel="prefetch" href="/fed-note/assets/js/13.415845a0.js"><link rel="prefetch" href="/fed-note/assets/js/14.c12b871a.js"><link rel="prefetch" href="/fed-note/assets/js/15.797802cd.js"><link rel="prefetch" href="/fed-note/assets/js/16.e18a12b9.js"><link rel="prefetch" href="/fed-note/assets/js/17.f862543c.js"><link rel="prefetch" href="/fed-note/assets/js/18.9e95df10.js"><link rel="prefetch" href="/fed-note/assets/js/19.05c393b3.js"><link rel="prefetch" href="/fed-note/assets/js/20.8809db0a.js"><link rel="prefetch" href="/fed-note/assets/js/21.8a969975.js"><link rel="prefetch" href="/fed-note/assets/js/22.a4b7c25c.js"><link rel="prefetch" href="/fed-note/assets/js/23.e5031cc2.js"><link rel="prefetch" href="/fed-note/assets/js/24.46de5072.js"><link rel="prefetch" href="/fed-note/assets/js/25.fdb7a3a3.js"><link rel="prefetch" href="/fed-note/assets/js/26.7998ccbf.js"><link rel="prefetch" href="/fed-note/assets/js/27.80db6f18.js"><link rel="prefetch" href="/fed-note/assets/js/28.f664c9b5.js"><link rel="prefetch" href="/fed-note/assets/js/29.755fac7d.js"><link rel="prefetch" href="/fed-note/assets/js/3.8bac98c2.js"><link rel="prefetch" href="/fed-note/assets/js/30.ca47500f.js"><link rel="prefetch" href="/fed-note/assets/js/31.7153b9a3.js"><link rel="prefetch" href="/fed-note/assets/js/32.f5bfb929.js"><link rel="prefetch" href="/fed-note/assets/js/33.123d1ce8.js"><link rel="prefetch" href="/fed-note/assets/js/34.2fdbcc65.js"><link rel="prefetch" href="/fed-note/assets/js/35.fe4d0657.js"><link rel="prefetch" href="/fed-note/assets/js/36.9d8b1a51.js"><link rel="prefetch" href="/fed-note/assets/js/37.b14f26e4.js"><link rel="prefetch" href="/fed-note/assets/js/38.de5a472c.js"><link rel="prefetch" href="/fed-note/assets/js/39.fd390308.js"><link rel="prefetch" href="/fed-note/assets/js/4.3fab20f1.js"><link rel="prefetch" href="/fed-note/assets/js/40.bac257c2.js"><link rel="prefetch" href="/fed-note/assets/js/41.5b6af204.js"><link rel="prefetch" href="/fed-note/assets/js/42.aa7828a9.js"><link rel="prefetch" href="/fed-note/assets/js/43.cce6ec34.js"><link rel="prefetch" href="/fed-note/assets/js/44.c0358b9b.js"><link rel="prefetch" href="/fed-note/assets/js/45.7b33bba3.js"><link rel="prefetch" href="/fed-note/assets/js/46.26543380.js"><link rel="prefetch" href="/fed-note/assets/js/47.52c7c426.js"><link rel="prefetch" href="/fed-note/assets/js/48.f8725195.js"><link rel="prefetch" href="/fed-note/assets/js/49.f1b03a84.js"><link rel="prefetch" href="/fed-note/assets/js/5.7bd620a8.js"><link rel="prefetch" href="/fed-note/assets/js/50.939b7361.js"><link rel="prefetch" href="/fed-note/assets/js/51.01fef418.js"><link rel="prefetch" href="/fed-note/assets/js/52.a265ba2e.js"><link rel="prefetch" href="/fed-note/assets/js/53.bd59c660.js"><link rel="prefetch" href="/fed-note/assets/js/54.d64353b5.js"><link rel="prefetch" href="/fed-note/assets/js/55.dd658087.js"><link rel="prefetch" href="/fed-note/assets/js/56.10f880f7.js"><link rel="prefetch" href="/fed-note/assets/js/57.df4ccbbc.js"><link rel="prefetch" href="/fed-note/assets/js/58.d893fce3.js"><link rel="prefetch" href="/fed-note/assets/js/59.8a464a5a.js"><link rel="prefetch" href="/fed-note/assets/js/60.76cb32da.js"><link rel="prefetch" href="/fed-note/assets/js/61.ac87701a.js"><link rel="prefetch" href="/fed-note/assets/js/62.ee2d6e80.js"><link rel="prefetch" href="/fed-note/assets/js/63.a702414e.js"><link rel="prefetch" href="/fed-note/assets/js/64.177e4700.js"><link rel="prefetch" href="/fed-note/assets/js/65.7af8568e.js"><link rel="prefetch" href="/fed-note/assets/js/66.4c2751c7.js"><link rel="prefetch" href="/fed-note/assets/js/67.5d5f7032.js"><link rel="prefetch" href="/fed-note/assets/js/68.5586c717.js"><link rel="prefetch" href="/fed-note/assets/js/69.455158fe.js"><link rel="prefetch" href="/fed-note/assets/js/7.75ecf1db.js"><link rel="prefetch" href="/fed-note/assets/js/70.4d6d6d2f.js"><link rel="prefetch" href="/fed-note/assets/js/71.ec8cfd97.js"><link rel="prefetch" href="/fed-note/assets/js/72.8a34da9c.js"><link rel="prefetch" href="/fed-note/assets/js/73.7ed2af01.js"><link rel="prefetch" href="/fed-note/assets/js/74.b3e3c021.js"><link rel="prefetch" href="/fed-note/assets/js/75.8307eba6.js"><link rel="prefetch" href="/fed-note/assets/js/76.90b1881a.js"><link rel="prefetch" href="/fed-note/assets/js/77.7f7a727a.js"><link rel="prefetch" href="/fed-note/assets/js/78.f1b88ff3.js"><link rel="prefetch" href="/fed-note/assets/js/8.0f83be65.js"><link rel="prefetch" href="/fed-note/assets/js/9.65a62eaa.js">
    <link rel="stylesheet" href="/fed-note/assets/css/0.styles.35bbaf6d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fed-note/" class="home-link router-link-active"><img src="/fed-note/mh.jpg" alt="Mokou的小书房" class="logo"> <span class="site-name can-hide">Mokou的小书房</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fed-note/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://github.com/zhongmeizhi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fed-note/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://github.com/zhongmeizhi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出 Vue3</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue2 &amp;&amp; React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fed-note/algorithm/base.html" aria-current="page" class="active sidebar-link">基本概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fed-note/algorithm/base.html#基础知识" class="sidebar-link">基础知识</a></li><li class="sidebar-sub-header"><a href="/fed-note/algorithm/base.html#五大算法" class="sidebar-link">五大算法</a></li><li class="sidebar-sub-header"><a href="/fed-note/algorithm/base.html#算法技巧" class="sidebar-link">算法技巧</a></li><li class="sidebar-sub-header"><a href="/fed-note/algorithm/base.html#复杂数据结构" class="sidebar-link">复杂数据结构</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>手写代码合集</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter实战</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>服务端相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>简单的API</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>经验之谈</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="算法基础"><a href="#算法基础" class="header-anchor">#</a> 算法基础</h1> <h2 id="基础知识"><a href="#基础知识" class="header-anchor">#</a> 基础知识</h2> <h3 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h3> <blockquote><p>数据结构是在计算机中组织数据以便有效使用的一种特殊方式。</p></blockquote> <p>常用的数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树</p> <p>其中最基础的是：数组和链表</p> <h4 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h4> <blockquote><p>数组是一块连续的内存空间，可以通过下标准确的查找到元素位置，但是不适合插入和删除元素。</p></blockquote> <p>那么通过调用 <code>splice</code> 实现插入和删除会怎么样呢？这里分析下 <code>splice</code> 的内部实现（顺便提一下<code>unshift</code>）</p> <p>首先要从堆栈开始说，如果你创建了一个数组那么从本质上讲你是在告诉系统需要在内存中开辟多大的堆栈分配空间。当你使用 <code>push</code> 时数据会被添加到堆栈的末尾，此时系统发现空间不够大将，然后它分配一个新的空间并将数据复制到新空间，这也就是java的数组为什么一定要指定长度的原因。</p> <p>然后说 <code>splice</code> 和 <code>unshift</code>，按照上面的推理：系统如何在数组的前面或者中间开辟一个空间呢？因为数组的内存可以看成一个线性的空间，如果要在数据堆栈已经被占用的情况下在前面添加一个元素，那么必须要将前面的元素位置后移，即从<code>N</code>迁移到<code>N+1</code>，也就是说使用 <code>unshift</code> 和 <code>splice</code> 的时候会重新分配内存并复制数据。</p> <p>下图是 unshift 和 push 的性能曲线，unshift 近似指数型增长</p> <p><img src="/fed-note/assets/img/unshift.2278dd9b.png" alt="unshift"></p> <h4 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h4> <blockquote><p>链表是不连续的代码片段，通过 next 属性连接后一个元素，从而实现链式结构，适合删除和插入元素</p></blockquote> <ul><li>链表的好处：可以随意穿插元素，只需要替换next的内容就可以了。
<ul><li>链表读取的运行时间是 O(n)</li> <li>链表插入的运行时间是 O(1)</li></ul></li> <li>数组的好处：数组知道每一个元素的地址，而链表需要从头开始遍历。
<ul><li>数组读取的运行时间是 O(1)</li> <li>数组插入的运行时间是 O(n)</li></ul></li></ul> <p>主要的链表结构：</p> <ol><li>单链表：尾节点的 next 为空</li> <li>循环链表：尾节点的 next 指向首节点</li> <li>双链表：节点不仅有 next 还有 prev 指向上一个节点（当然内存占用大）</li></ol> <p>王争老师的几个链表练习推荐（LeetCode对应编号：206，141，21，19，876。）</p> <ul><li>单链表反转</li> <li>链表中环的检测</li> <li>两个有序的链表合并</li> <li>删除链表倒数第 n 个结点</li> <li>求链表的中间结点</li></ul> <h3 id="大o表示法"><a href="#大o表示法" class="header-anchor">#</a> 大O表示法</h3> <p>什么是大O表示法？</p> <p>大O表示法表示的是<strong>忽略系数和常量后最糟糕的运行时间</strong>，比如：普通遍历100个元素的数组，最少1次就找到元素，最多查找100次。这样去最糟糕运行时间，也就是时间复杂度为<code>O(n)</code></p> <p>为什么需要大O表示法？</p> <p>算法的速度并非时间，而是操作数的增速。大O表示法可以更加直观的方式表示算法的计算效率。</p> <p>比如：如果查询100个元素的list，普通遍历需要100次，二分法需要7次。看起来二分法的查找效率是普通遍历的15倍。而如果查询1亿个元素的list，二分法需要32次，通过上面得出的结论，普通遍历只需要 32*15 次，但是实际上是1亿次。用大O表示法，普通遍历是O(n)而二分法是O(log n)</p> <p>常见的大O表示法运行时间</p> <ul><li><code>O(log n)</code>：对数时间，比如：二分法</li> <li><code>O(n)</code>：线性时间，比如：简单遍历</li> <li><code>O(n * log n)</code>：比如：快排</li> <li><code>O(n^2)</code>：比如：选择排序</li> <li><code>O(n!)</code>：n的阶乘，比如：旅行商问题</li></ul> <p>大O表示法的log计算时比较复杂的。这里单独列出来，《算法图解》里面是这么介绍的：</p> <p><img src="/fed-note/assets/img/log.8762d8b3.png" alt="log"></p> <p>实际场景中：当我们遇到下面算法时应该怎么计算？</p> <div class="language-js extra-class"><pre class="language-js"><code>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
  i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token comment">//  或者 i = i * 3; i = i * 10;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要比较 i 和 n 的大小，而 i 每次都乘 2，得到 i 每次计算的值分别为 2、2<sup>2</sup>、2<sup>3</sup>、...、2<sup>x</sup></p> <p>最后得到 ：2<sup>x</sup> = n; 则 复杂度为 log<sub>2</sub>n</p> <p>由于大O表示法会忽略系数和常量，所以最后得到复杂度为 <code>log n</code></p> <h2 id="五大算法"><a href="#五大算法" class="header-anchor">#</a> 五大算法</h2> <blockquote><p>递归、分治、动态规划、贪心算法 是必须要掌握的</p></blockquote> <h3 id="一、分治算法-（divide-and-conquer，简称：dc）"><a href="#一、分治算法-（divide-and-conquer，简称：dc）" class="header-anchor">#</a> 一、分治算法 （Divide And Conquer，简称：DC）</h3> <blockquote><p>将规模为 N 的问题分解为 K 个规模较小的子问题，这些<strong>子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解</strong></p></blockquote> <p>分治算法一般都会用递归实现。步骤为：</p> <ol><li>分解：大问题分解为小问题</li> <li>解决：如果问题足够小则直接求解</li> <li>合并：将小问题的结果合并</li></ol> <p>举例：归并排序</p> <p>ps：归并排序就是一种排序算法，其时间复杂度为 O(n*logn)，仅次于快速排序</p> <p>实现思路：将已排序的子项合并。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 归并排序 -&gt; 利用分治递归思想</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 拆分</span>
  <span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> item<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> item<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span>  item<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> right <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 合并子项</span>
  <span class="token comment">// 该合并有很大缺陷，因为使用了shift</span>
  <span class="token comment">// function merge(left, right) {</span>
  <span class="token comment">// 	const leftLen = left.length;</span>
  <span class="token comment">// 	const rightLen = right.length;</span>
  <span class="token comment">// 	let result = [];</span>
  <span class="token comment">// 	while(left.length &gt; 0 &amp;&amp; right.length &gt; 0) {</span>
  <span class="token comment">// 		if (left[0] &lt; right[0]) {</span>
  <span class="token comment">// 			result.push(left.shift())</span>
  <span class="token comment">// 		} else {</span>
  <span class="token comment">// 			result.push(right.shift())</span>
  <span class="token comment">// 		}</span>
  <span class="token comment">// 	}</span>
  <span class="token comment">// 	return result.concat(left).concat(right)</span>
  <span class="token comment">// }</span>
  
  <span class="token comment">// 合并子项</span>
  <span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> il <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ir <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  
    <span class="token comment">// left, right本身肯定都是从小到大排好序的</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>il <span class="token operator">&lt;</span> left<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> ir <span class="token operator">&lt;</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span>il<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span>ir<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>il<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        il<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>ir<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ir<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 当有一方遍历结束后，将有剩余放push到已排序数组</span>
    <span class="token comment">// 左边</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>il <span class="token operator">&lt;</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>il<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      il<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 右边</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>ir <span class="token operator">&lt;</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>ir<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ir<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token string">'arr'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token string">'result'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="二、动态规划算法（dynamic-programming，简称：dp）"><a href="#二、动态规划算法（dynamic-programming，简称：dp）" class="header-anchor">#</a> 二、动态规划算法（Dynamic Programming，简称：DP）</h3> <blockquote><p>类似于分治算法，将待求解问题分解成若干个子问题，先求解子问题，然后从子问题的解得到原问题的解。与分治法不同的是，<strong>经分解得到子问题往往不是互相独立的</strong></p></blockquote> <p>举例：斐波那契数列 0,1,1,2,3,5,8,13,…</p> <p>它的每个数字都与前两个紧邻的数字相关。如果 F(n) 是第 n 个数字，那么我们会有 <code>F(n) = F(n-1) + F(n-2)</code>。这个在数学上称作<em>递归方程</em>或者<em>递推关系</em>。为了计算后面的项，它需要前面项的计算结果作为输入</p> <h3 id="三、贪心算法"><a href="#三、贪心算法" class="header-anchor">#</a> 三、贪心算法</h3> <blockquote><p>在对问题求解时，<strong>总是做出在当前看来是最好的选择</strong>。也就是说，不从整体最优考虑，算法得到的是局部最优解</p></blockquote> <p>故：使用贪心算法时前面的选择不能影响后续的选择</p> <h4 id="案例1"><a href="#案例1" class="header-anchor">#</a> 案例1</h4> <p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/" target="_blank" rel="noopener noreferrer">买卖股票的最佳时机 II<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p> <p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <p>示例 1:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [7,1,5,3,6,4]

输出: 7

解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre></div><p>解题思路：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>从第 i 天（这里 i &gt;= 1）开始，与第 i - 1 的股价进行比较，如果股价有上升（严格上升），就将升高的股价（ prices[i] - prices[i- 1] ）记入总利润，按照这种算法，得到的结果就是符合题意的最大利润。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 也就是说只要能赚钱就进行一次买卖。</span>
<span class="token keyword">let</span> res <span class="token operator">=</span>  <span class="token punctuation">(</span>prices<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 等价于</span>
<span class="token keyword">let</span> res <span class="token operator">=</span>  prices<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre></div><h4 id="案例2"><a href="#案例2" class="header-anchor">#</a> 案例2:</h4> <p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p> <p>解题思路：找到当前节点的最优解，即用面值最大的进行支付。如果不够，就继续用第二大的进行支付。</p> <h3 id="四、回溯算法"><a href="#四、回溯算法" class="header-anchor">#</a> 四、回溯算法</h3> <blockquote><p>回溯法是一种搜索算法，类似枚举的搜索尝试过程。复杂的，规模较大的问题都可以使用回溯法</p></blockquote> <p>回溯：也就是进行一次次的尝试（穷举）</p> <p>案例：数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列</p> <p>似乎都像是暴力求解</p> <h3 id="五、分支限界法"><a href="#五、分支限界法" class="header-anchor">#</a> 五、分支限界法</h3> <blockquote><p>回溯算法是深度优先，那么分支限界法就是广度优先的一个经典的例子。回溯法一般来说是遍历整个解空间，获取问题的所有解，而分支限界法则是获取一个解</p></blockquote> <p>了解了解就好了...</p> <h2 id="算法技巧"><a href="#算法技巧" class="header-anchor">#</a> 算法技巧</h2> <h3 id="双指针"><a href="#双指针" class="header-anchor">#</a> 双指针</h3> <blockquote><p>双指针在处理链表的时候特别有用</p></blockquote> <h4 id="案例1：判断单链表是否成环（快慢指针）"><a href="#案例1：判断单链表是否成环（快慢指针）" class="header-anchor">#</a> 案例1：判断单链表是否成环（快慢指针）</h4> <p>如果单链表成环，那么必定出现慢指针和快指针重合的情况</p> <p>案例2: <a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/" target="_blank" rel="noopener noreferrer">删除排序数组中的重复项<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="案例2-不实用indexof实现字符串includes"><a href="#案例2-不实用indexof实现字符串includes" class="header-anchor">#</a> 案例2: 不实用indexof实现字符串includes</h4> <p>通过双指针确定需要从字符串中获取的内容长度（star指针和end指针），通过slice获取样本（如果不能使用slice方法可以通队列实现一个），然后用样本和校验值做比较，如果不匹配就star和end递增。</p> <h3 id="散列思想"><a href="#散列思想" class="header-anchor">#</a> 散列思想</h3> <p>就是用map储存数据，从而形成一个hash表，然后用hash表储存数据</p> <h5 id="案例1：两数之和"><a href="#案例1：两数之和" class="header-anchor">#</a> 案例1：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener noreferrer">两数之和<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h5> <h2 id="复杂数据结构"><a href="#复杂数据结构" class="header-anchor">#</a> 复杂数据结构</h2> <h3 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h3> <blockquote><p>栈是一种：后进先出结构</p></blockquote> <p>常用的栈结构有：浏览器的前进后退，V8的上下文调用栈</p> <p>栈是基于数组/链表实现的：</p> <ol><li><p>用数组实现栈：（顺序栈）</p></li> <li><p>用链表实现栈：（链式栈）</p></li></ol> <h3 id="散列表（hash-表）"><a href="#散列表（hash-表）" class="header-anchor">#</a> 散列表（hash 表）</h3> <blockquote><p>插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。</p></blockquote> <p>散列表是根据 key-value 来访问的，通过散列函数来寻找映射。</p> <p>适用于那些不需要顺序遍历，数据更新不那么频繁的。</p> <h3 id="跳表"><a href="#跳表" class="header-anchor">#</a> 跳表</h3> <blockquote><p>插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。</p></blockquote> <p>跳表是在链表的基础上添加多级索引（类似于二分法）</p> <p>适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。Redis 中的有序集合（Sorted Set）就是用跳表来实现的。</p> <h3 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h3> <blockquote><p>树是一种非线性数据结构，常说的树都是查找树</p></blockquote> <p>树可以看成是链表的变体，链表中添加了left/right等属性从产生了树状结构</p> <h3 id="红黑树"><a href="#红黑树" class="header-anchor">#</a> 红黑树</h3> <blockquote><p>插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。</p></blockquote> <p>红黑树是一个<code>近似平衡二叉树</code></p> <p>红黑树相对跳表实现更为复杂，但红黑树历史更久并已经在多处使用。</p> <h3 id="字典树（trie-树）"><a href="#字典树（trie-树）" class="header-anchor">#</a> 字典树（Trie 树）</h3> <blockquote><p>适合查找前缀匹配的字符串，很消耗内存</p></blockquote> <p>应用场景：比如谷歌搜索时关键字提示</p> <p>就是把字符串分割，按顺序放入树中：比如 here 和 hero 的前面都是 h（第一层）、e（第二层）</p> <h3 id="图"><a href="#图" class="header-anchor">#</a> 图</h3> <blockquote><p>图用来形容关系</p></blockquote> <p>应用场景：朋友圈、微博等好友关系</p> <p>常用的图</p> <ol><li>邻接矩阵（也就是二维数组），空间占用大</li> <li>邻接表（一维数组 + 链表）</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/fed-note/sse/design_model.html" class="prev">
        设计模式
      </a></span> <span class="next"><a href="/fed-note/css/mobile.html">
        移动端-适配
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/fed-note/assets/js/app.15a9732a.js" defer></script><script src="/fed-note/assets/js/2.6fa16ecd.js" defer></script><script src="/fed-note/assets/js/6.13ba1568.js" defer></script>
  </body>
</html>
