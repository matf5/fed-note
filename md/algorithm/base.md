# 算法基础

## 基础知识

### 数据结构

> 数据结构是在计算机中组织数据以便有效使用的一种特殊方式。

常用的数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树

实际使用过程中最常用的是：数组和链表

##### 数组

> 数组是一块连续的内存空间，可以通过下标准确的查找到元素位置，但是不适合插入和删除元素。

那么通过调用 `splice` 实现插入和删除会怎么样呢？这里分析下 `splice` 的内部实现（顺便提一下`unshift`）

首先要从堆栈开始说，如果你创建了一个数组那么从本质上讲你是在告诉系统需要在内存中开辟多大的堆栈分配空间。当你使用 `push` 时数据会被添加到堆栈的末尾，此时系统发现空间不够大将，然后它分配一个新的空间并将数据复制到新空间，这也就是java的数组为什么一定要指定长度的原因。

然后说 `splice` 和 `unshift`，按照上面的推理：系统如何在数组的前面或者中间开辟一个空间呢？因为数组的内存可以看成一个线性的空间，如果要在数据堆栈已经被占用的情况下在前面添加一个元素，那么必须要将前面的元素位置后移，即从`N`迁移到`N+1`，也就是说使用 `unshift` 和 `splice` 的时候会重新分配内存并复制数据。

下图是 unshift 和 push 的性能曲线，unshift 近似指数型增长

![unshift](../img/algorithm/unshift.png)

##### 链表

> 链表是不连续的代码片段，通过 next 属性连接后一个元素，从而实现链式结构，适合删除和插入元素

* 链表的好处：可以随意穿插元素，只需要替换next的内容就可以了。
  * 链表读取的运行时间是 O(n)
  * 链表插入的运行时间是 O(1)
* 数组的好处：数组知道每一个元素的地址，而链表需要从头开始遍历。
  * 数组读取的运行时间是 O(1)
  * 数组插入的运行时间是 O(n)

主要的链表结构：

1. 单链表：尾节点的 next 为空
2. 循环链表：尾节点的 next 指向首节点
3. 双链表：节点不仅有 next 还有 prev 指向上一个节点（当然内存占用大）

王争老师的几个链表练习推荐（LeetCode对应编号：206，141，21，19，876。）

* 单链表反转
* 链表中环的检测
* 两个有序的链表合并
* 删除链表倒数第 n 个结点
* 求链表的中间结点

##### 栈

> 栈是一种：后进先出结构

常用的栈结构有：浏览器的前进后退，V8的上下文调用栈

用数组实现栈：（顺序栈）

用链表实现栈：（链式栈）



### 大O表示法

什么是大O表示法？

大O表示法表示的是**忽略系数和常量后最糟糕的运行时间**，比如：普通遍历100个元素的数组，最少1次就找到元素，最多查找100次。这样去最糟糕运行时间，也就是时间复杂度为`O(n)`


为什么需要大O表示法？

算法的速度并非时间，而是操作数的增速。大O表示法可以更加直观的方式表示算法的计算效率。

比如：如果查询100个元素的list，普通遍历需要100次，二分法需要7次。看起来二分法的查找效率是普通遍历的15倍。而如果查询1亿个元素的list，二分法需要32次，通过上面得出的结论，普通遍历只需要 32*15 次，但是实际上是1亿次。用大O表示法，普通遍历是O(n)而二分法是O(log n)

常见的大O表示法运行时间

* `O(log n)`：对数时间，比如：二分法
* `O(n)`：线性时间，比如：简单遍历
* `O(n * log n)`：比如：快排
* `O(n^2)`：比如：选择排序
* `O(n!)`：n的阶乘，比如：旅行商问题


大O表示法的log计算时比较复杂的。这里单独列出来，《算法图解》里面是这么介绍的：

![log](../img/algorithm/log.png)

实际场景中：当我们遇到下面算法时应该怎么计算？

 ```js
 i=1;
 while (i <= n)  {
   i = i * 2;
   //  或者 i = i * 3; i = i * 10;
 }
 ```

要比较 i 和 n 的大小，而 i 每次都乘 2，得到 i 每次计算的值分别为 2、2<sup>2</sup>、2<sup>3</sup>、...、2<sup>x</sup>

最后得到 ：2<sup>x</sup> = n; 则 复杂度为 log<sub>2</sub>n

由于大O表示法会忽略系数和常量，所以最后得到复杂度为 `log n`


## 五大算法

> 递归、分治、动态规划、贪心算法 是必须要掌握的

### 一、分治算法 （Divide And Conquer，简称：DC）

> 将规模为 N 的问题分解为 K 个规模较小的子问题，这些**子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解**

举例：



### 二、动态规划算法（Dynamic Programming，简称：DP）

> 类似于分治算法，将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，**经分解得到子问题往往不是互相独立的**

举例：斐波那契数列 0,1,1,2,3,5,8,13,…

它的每个数字都与前两个紧邻的数字相关。如果 F(n) 是第 n 个数字，那么我们会有 `F(n) = F(n-1) + F(n-2)`。这个在数学上称作*递归方程*或者*递推关系*。为了计算后面的项，它需要前面项的计算结果作为输入


### 三、贪心算法

> 在对问题求解时，**总是做出在当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解

案例：[买卖股票的最佳时机 II](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```
输入: [7,1,5,3,6,4]

输出: 7

解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

解题思路：[参考](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/)

从第 i 天（这里 i >= 1）开始，与第 i - 1 的股价进行比较，如果股价有上升（严格上升），就将升高的股价（ prices[i] - prices[i- 1] ）记入总利润，按照这种算法，得到的结果就是符合题意的最大利润。


```js
// 也就是说只要能赚钱就进行一次买卖。
let res =  (prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])

// 等价于
let res =  prices[3] - prices[0]
```

### 四、回溯算法

> 回溯法是一种搜索算法，类似枚举的搜索尝试过程。复杂的，规模较大的问题都可以使用回溯法

案例：八皇后问题


### 五、分支限界法

> 回溯算法是深度优先，那么分支限界法就是广度优先的一个经典的例子。回溯法一般来说是遍历整个解空间，获取问题的所有解，而分支限界法则是获取一个解



## 算法技巧

### 双指针

> 双指针在处理链表的时候特别有用

案例1：判断单链表是否成环（快慢指针）

如果单链表成环，那么必定出现慢指针和快指针重合的情况

案例2: [删除排序数组中的重复项](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/)

### 二分查找

就是分两份咯
