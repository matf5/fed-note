# JS 执行上下文

1. 宿主(浏览器和node)和v8的关系
   1. node和浏览器事件循环系统不一致
   2. dom操作会很慢？
2. v8的执行过程 编译 执行 热代码
3. 声明、 if、严格模式
   1. 为什么会有变量提升？
      1. 因为js代码解析的结果会放到内存中
      2. 所以v8的js代码采用惰性解析
      3. 
4. 堆栈结构、执行上下文，执行上下文的垃圾回收
   1. 为什么采用堆栈结构？
      1. 方便移交控制权
   2. 执行上下文不同ES版本会不一样
   3. 堆栈结构的栈溢出和异常提示
   4. 解决栈溢出问题，协程和尾递归（部分没有）
   5. 调用栈的垃圾回收
      1. esp寄存器保存栈顶指针
      2. 当调用栈执行完成后，挪动栈顶指针，
      3. 下一次入栈时从指针开始进行覆盖
5. 变量环境和作用域链寻址
6. 块状结构、词法环境
7.  堆内存和栈内存
    1.  栈内存的好处（快）是线性结构的连续空间，堆内存（慢）是非连续空间
    2.  同理，计算机中有cpu的寄存器，内存，硬盘都可以存放数据，而硬盘存放的量最大，为什么不把数据都放到硬盘中？
8.  对象的字典结构和链式结构，快属性和慢属性
9.  unshift 和 push
10. 函数和为什么基于原形而不是基于类
11. 闭包 colsure，编译阶段，垃圾回收
12. 自执行函数anonymous 和（小括号）

全局执行上下文在 V8 的生存周期内是不会被销毁

## 为什么会出现变量提升？

讲变量提升之前先介绍下编程语言的有2种编译方式：`JIT` 和 `AOT`。

* AOT (Ahead-Of-Time - 预先编译)
  * 编译步骤：词法分析 -> 语法分析 -> 语义检查 -> 代码优化和字节码生成
* JIT（Just-In-Time - 实时编译）
  * 编译步骤：词法分析 -> 语法分析 -> 语法树 -> 解释执行

ps：具体js的语法分析结果可以查看：[JS语法分析成语法树](https://esprima.org/demo/parse.html#)

每种编译方式都有各自的优缺点，这里以js为例，js属于jit编译，这样的好处是可以做到动态的代码生成，也不会出现在引入js文件时出现长时间的编译操作。

### js解释执行

js解释执行严格按照js作用域链（scope chain）机制执行的，
