# JS 执行上下文

1. 宿主(浏览器和node)和v8的关系
   1. node和浏览器事件循环系统不一致
   2. dom操作会很慢？
2. v8的执行过程 编译 执行 热代码
3. 声明、 if、严格模式
4. 堆栈结构、执行上下文，执行上下文的垃圾回收
   1. 执行上下文不同ES版本会不一样
   2. 堆栈结构的栈溢出和异常提示
   3. 解决栈溢出问题，协程和尾递归（部分没有）
5. 变量环境和作用域链寻址
6. 块状结构、词法环境
7.  堆内存和栈内存
    1.  栈内存的好处（快）是线性结构的连续空间，堆内存（慢）是非连续空间
8.  对象的字典结构和链式结构，快属性和慢属性
9.  unshift 和 push
10. 函数和为什么基于原形而不是基于类
11. 闭包 colsure，编译阶段，垃圾回收
12. 自执行函数anonymous 和（小括号）

全局执行上下文在 V8 的生存周期内是不会被销毁

## 为什么会出现变量提升？

讲变量提升之前先介绍下编程语言的有2种编译方式：`JIT` 和 `AOT`。

* AOT (Ahead-Of-Time - 预先编译)
  * 编译步骤：词法分析 -> 语法分析 -> 语义检查 -> 代码优化和字节码生成
* JIT（Just-In-Time - 实时编译）
  * 编译步骤：词法分析 -> 语法分析 -> 语法树 -> 解释执行

ps：具体js的语法分析结果可以查看：[JS语法分析成语法树](https://esprima.org/demo/parse.html#)

每种编译方式都有各自的优缺点，这里以js为例，js属于jit编译，这样的好处是可以做到动态的代码生成，也不会出现在引入js文件时出现长时间的编译操作。

### js解释执行

js解释执行严格按照js作用域链（scope chain）机制执行的，
